import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.7.1';
import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
  LAMPORTS_PER_SOL,
  sendAndConfirmTransaction,
  Keypair,
  TransactionInstruction,
  AccountMeta,
} from "https://esm.sh/@solana/web3.js@1.98.2";
import {
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  createInitializeMintInstruction,
  createAssociatedTokenAccountInstruction,
  createMintToInstruction,
  getAssociatedTokenAddress,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
} from "https://esm.sh/@solana/spl-token@0.4.8";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Bonding curve constants
const BONDING_CURVE_CONFIG = {
  VIRTUAL_SOL_RESERVES: 30 * LAMPORTS_PER_SOL,
  VIRTUAL_TOKEN_RESERVES: 1073000000,
  BONDING_CURVE_SUPPLY: 800000000,
  CREATOR_SUPPLY: 200000000,
  TOTAL_SUPPLY: 1000000000,
  GRADUATION_THRESHOLD: 85000 * LAMPORTS_PER_SOL,
};

/**
 * Get bonding curve PDA
 */
function getBondingCurvePDA(mint: PublicKey, programId: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("bonding_curve"), mint.toBuffer()],
    programId
  );
}

/**
 * Create bonding curve initialization instruction
 */
function createInitializeCurveInstruction(
  bondingCurve: PublicKey,
  mint: PublicKey,
  curveTokenAccount: PublicKey,
  creator: PublicKey,
  programId: PublicKey,
  platformFee: number,
  creatorFee: number,
  prizePoolFee: number,
  reservesFee: number
): TransactionInstruction {
  // Instruction data for initialize_curve
  const instructionData = new Uint8Array(8 + 8 + 8 + 8 + 2 + 2 + 2 + 2);
  const dataView = new DataView(instructionData.buffer);
  
  // Instruction discriminator (placeholder - will be generated by Anchor)
  dataView.setBigUint64(0, BigInt(0), true);
  
  // Parameters
  dataView.setBigUint64(8, BigInt(BONDING_CURVE_CONFIG.VIRTUAL_SOL_RESERVES), true);
  dataView.setBigUint64(16, BigInt(BONDING_CURVE_CONFIG.VIRTUAL_TOKEN_RESERVES), true);
  dataView.setBigUint64(24, BigInt(BONDING_CURVE_CONFIG.BONDING_CURVE_SUPPLY * Math.pow(10, 9)), true);
  dataView.setUint16(32, platformFee, true);
  dataView.setUint16(34, creatorFee, true);
  dataView.setUint16(36, prizePoolFee, true);
  dataView.setUint16(38, reservesFee, true);

  const accounts: AccountMeta[] = [
    { pubkey: bondingCurve, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: curveTokenAccount, isSigner: false, isWritable: true },
    { pubkey: creator, isSigner: true, isWritable: true },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
  ];

  return new TransactionInstruction({
    keys: accounts,
    programId,
    data: instructionData,
  });
}

serve(async (req) => {
  console.log('=== CREATE BONDING CURVE TOKEN ===');
  console.log('Request method:', req.method);
  
  if (req.method === 'OPTIONS') {
    console.log('Handling OPTIONS request');
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('=== DEBUGGING ENVIRONMENT ===');
    console.log('All available env vars:', Object.keys(Deno.env.toObject()));
    
    // Environment check with detailed logging
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    const heliusKey = Deno.env.get('HELIUS_RPC_API_KEY');
    const platformKey = Deno.env.get('PLATFORM_WALLET_PRIVATE_KEY');
    
    console.log('Environment variables check:', {
      hasSupabaseUrl: !!supabaseUrl,
      hasSupabaseKey: !!supabaseKey,
      hasHeliusKey: !!heliusKey,
      hasPlatformKey: !!platformKey,
      supabaseUrlLength: supabaseUrl?.length || 0,
      supabaseKeyLength: supabaseKey?.length || 0,
      heliusKeyLength: heliusKey?.length || 0,
      platformKeyLength: platformKey?.length || 0
    });
    
    if (!supabaseUrl || !supabaseKey) {
      console.error('=== MISSING SUPABASE ENV VARS ===');
      throw new Error(`Missing Supabase environment variables - URL: ${!!supabaseUrl}, Key: ${!!supabaseKey}`);
    }
    
    if (!heliusKey) {
      console.error('=== MISSING HELIUS KEY ===');
      throw new Error('Helius RPC API key not configured');
    }
    
    if (!platformKey) {
      console.error('=== MISSING PLATFORM KEY ===');
      throw new Error('Platform wallet private key not configured');
    }
    
    // Create Supabase client
    console.log('Creating Supabase client...');
    const supabase = createClient(supabaseUrl, supabaseKey);
    console.log('✅ Supabase client created successfully');

    // Parse request body
    const requestBody = await req.json();
    console.log('JSON parsed successfully, keys:', Object.keys(requestBody));

    // Extract and validate required fields
    const { name, symbol, description, creatorWallet, imageUrl, telegram, twitter, signedTransaction } = requestBody;
    console.log('Extracted fields:', { name, symbol, creatorWallet });

    if (!name || !symbol || !description || !creatorWallet) {
      console.log('Missing required fields');
      return new Response(
        JSON.stringify({ error: 'Missing required fields: name, symbol, description, creatorWallet' }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 400 }
      );
    }

    // Rate limiting check
    console.log('Checking rate limit for creator:', creatorWallet);
    const { data: rateLimitResult, error: rateLimitError } = await supabase.rpc('check_creator_rate_limit', {
      p_creator_wallet: creatorWallet
    });

    console.log('Rate limit check result:', { rateLimitResult, rateLimitError });

    if (rateLimitError) {
      console.error('Rate limit error:', rateLimitError);
      return new Response(
        JSON.stringify({ error: 'Rate limit check failed', details: rateLimitError.message }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
      );
    }

    if (!rateLimitResult?.[0]?.allowed) {
      const reason = rateLimitResult?.[0]?.reason || 'Rate limit exceeded';
      console.log('Rate limit exceeded:', reason);
      return new Response(
        JSON.stringify({ 
          error: 'Token creation not allowed', 
          reason,
          tokensCreatedToday: rateLimitResult?.[0]?.tokens_created_today || 0,
          dailyLimit: rateLimitResult?.[0]?.daily_limit || 5
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 429 }
      );
    }

    // Get current program ID and fee configuration
    const { data: programId } = await supabase.rpc('get_active_program_id');
    const { data: feeConfig } = await supabase.rpc('get_active_fee_config');
    const realProgramId = programId || '11111111111111111111111111111111';

    // Initialize Solana connection
    console.log('Initializing Solana connection...');
    const heliusRpcApiKey = Deno.env.get('HELIUS_RPC_API_KEY');
    if (!heliusRpcApiKey) {
      console.error('Helius RPC API key not found');
      throw new Error('Helius RPC API key not configured');
    }
    
    const heliusRpcUrl = `https://devnet.helius-rpc.com/?api-key=${heliusRpcApiKey}`;
    console.log('Connecting to Helius RPC...');
    const connection = new Connection(heliusRpcUrl, 'confirmed');
    console.log('✅ Solana connection established');

    // Get platform keypair
    console.log('Setting up platform keypair...');
    const platformPrivateKey = Deno.env.get('PLATFORM_WALLET_PRIVATE_KEY');
    if (!platformPrivateKey) {
      console.error('Platform wallet private key not found');
      throw new Error('Platform wallet private key not configured');
    }

    let platformKeypair;
    try {
      // Try parsing as base58 string first (recommended format)
      console.log('Attempting to parse private key as base58...');
      const bs58 = await import('https://esm.sh/bs58@5.0.0');
      const secretKeyBytes = bs58.default.decode(platformPrivateKey);
      platformKeypair = Keypair.fromSecretKey(secretKeyBytes);
      console.log('✅ Parsed private key as base58');
    } catch (base58Error) {
      try {
        // Fallback: try parsing as JSON array
        console.log('Base58 failed, trying JSON array format...');
        const secretKeyArray = JSON.parse(platformPrivateKey);
        platformKeypair = Keypair.fromSecretKey(Uint8Array.from(secretKeyArray));
        console.log('✅ Parsed private key as JSON array');
      } catch (jsonError) {
        console.error('Both parsing methods failed:', { base58Error: base58Error.message, jsonError: jsonError.message });
        throw new Error('Invalid private key format. Please provide as base58 string or JSON array');
      }
    }

    // Generate new mint and bonding curve addresses
    const mint = Keypair.generate();
    const creatorPublicKey = new PublicKey(creatorWallet);
    const bondingCurveProgramId = new PublicKey(realProgramId);
    const [bondingCurve] = getBondingCurvePDA(mint.publicKey, bondingCurveProgramId);

    // Get token accounts
    const curveTokenAccount = await getAssociatedTokenAddress(
      mint.publicKey,
      bondingCurve,
      true // allowOwnerOffCurve
    );

    const creatorTokenAccount = await getAssociatedTokenAddress(
      mint.publicKey,
      creatorPublicKey
    );

    console.log('Generated addresses:', {
      mint: mint.publicKey.toString(),
      bondingCurve: bondingCurve.toString(),
      programId: realProgramId
    });

    // Execute user's signed transaction (payment transaction) - skip if no transaction provided
    let userTxId = null;
    if (signedTransaction) {
      const userTransaction = Transaction.from(Uint8Array.from(signedTransaction));
      console.log('Submitting user payment transaction...');
      userTxId = await connection.sendRawTransaction(userTransaction.serialize());
      await connection.confirmTransaction(userTxId);
      console.log('✅ User payment confirmed:', userTxId);
    } else {
      console.log('⏭️ No payment transaction provided, proceeding without payment...');
    }

    // Create token mint and bonding curve
    const createTokenTx = new Transaction();

    // Create mint account
    createTokenTx.add(
      SystemProgram.createAccount({
        fromPubkey: platformKeypair.publicKey,
        newAccountPubkey: mint.publicKey,
        space: MINT_SIZE,
        lamports: await getMinimumBalanceForRentExemptMint(connection),
        programId: TOKEN_PROGRAM_ID,
      })
    );

    // Initialize mint
    createTokenTx.add(
      createInitializeMintInstruction(
        mint.publicKey,
        9, // decimals
        platformKeypair.publicKey, // mint authority
        null, // freeze authority
        TOKEN_PROGRAM_ID
      )
    );

    // Create bonding curve token account
    createTokenTx.add(
      createAssociatedTokenAccountInstruction(
        platformKeypair.publicKey, // payer
        curveTokenAccount,
        bondingCurve, // owner
        mint.publicKey
      )
    );

    // Create creator token account
    createTokenTx.add(
      createAssociatedTokenAccountInstruction(
        platformKeypair.publicKey, // payer
        creatorTokenAccount,
        creatorPublicKey, // owner
        mint.publicKey
      )
    );

    // Mint bonding curve supply to curve account
    createTokenTx.add(
      createMintToInstruction(
        mint.publicKey,
        curveTokenAccount,
        platformKeypair.publicKey, // mint authority
        BONDING_CURVE_CONFIG.BONDING_CURVE_SUPPLY * Math.pow(10, 9)
      )
    );

    // Mint creator supply to creator account
    createTokenTx.add(
      createMintToInstruction(
        mint.publicKey,
        creatorTokenAccount,
        platformKeypair.publicKey, // mint authority
        BONDING_CURVE_CONFIG.CREATOR_SUPPLY * Math.pow(10, 9)
      )
    );

    // Add bonding curve initialization instruction (if real program ID is available)
    if (realProgramId !== '11111111111111111111111111111111') {
      const fees = feeConfig?.[0] || { platform_fee_bps: 100, creator_fee_bps: 70, prize_pool_fee_bps: 20, reserves_fee_bps: 10 };
      
      createTokenTx.add(
        createInitializeCurveInstruction(
          bondingCurve,
          mint.publicKey,
          curveTokenAccount,
          platformKeypair.publicKey,
          bondingCurveProgramId,
          fees.platform_fee_bps,
          fees.creator_fee_bps,
          fees.prize_pool_fee_bps,
          fees.reserves_fee_bps
        )
      );
    }

    // Get recent blockhash and send transaction
    const { blockhash } = await connection.getLatestBlockhash();
    createTokenTx.recentBlockhash = blockhash;
    createTokenTx.feePayer = platformKeypair.publicKey;

    console.log('Creating token and bonding curve...');
    const createTxId = await sendAndConfirmTransaction(
      connection,
      createTokenTx,
      [platformKeypair, mint]
    );
    console.log('✅ Token creation confirmed:', createTxId);

    // Calculate initial state
    const virtualSol = BONDING_CURVE_CONFIG.VIRTUAL_SOL_RESERVES / LAMPORTS_PER_SOL;
    const virtualTokens = BONDING_CURVE_CONFIG.VIRTUAL_TOKEN_RESERVES;
    const initialPrice = virtualSol / virtualTokens;
    const initialMarketCap = initialPrice * BONDING_CURVE_CONFIG.TOTAL_SUPPLY;

    // Generate platform signature for trading authorization
    const platformSignature = `platform_sig_${Date.now()}_${mint.publicKey.toString()}`;
    const signatureExpiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    // Store token in database
    const { data: token, error: insertError } = await supabase
      .from('tokens')
      .insert({
        name,
        symbol,
        description,
        image_url: imageUrl,
        x_url: twitter,
        telegram_url: telegram,
        creator_wallet: creatorWallet,
        mint_address: mint.publicKey.toString(),
        bonding_curve_address: bondingCurve.toString(),
        curve_token_account: curveTokenAccount.toString(),
        creator_token_account: creatorTokenAccount.toString(),
        total_supply: BONDING_CURVE_CONFIG.TOTAL_SUPPLY,
        decimals: 9,
        sol_raised: 0,
        tokens_sold: 0,
        market_cap: initialMarketCap,
        price: initialPrice,
        is_graduated: false,
        holder_count: 1, // Creator
        volume_24h: 0,
        price_change_24h: 0,
        platform_signature: platformSignature,
        signature_expires_at: signatureExpiresAt.toISOString(),
        creation_tx: createTxId,
        user_payment_tx: userTxId,
      })
      .select()
      .single();

    if (insertError) {
      console.error('Database insert error:', insertError);
      return new Response(
        JSON.stringify({ error: 'Failed to save token to database', details: insertError.message }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
      );
    }

    // Initialize creator credits and deduct one
    await supabase.rpc('initialize_creator_credits', { p_user_wallet: creatorWallet });
    
    // Check for achievements
    try {
      await supabase.rpc('check_and_award_achievements', {
        p_user_wallet: creatorWallet,
        p_token_id: token.id,
        p_check_type: 'milestone'
      });
    } catch (error) {
      console.error('Achievement check failed:', error);
    }

    console.log('🎉 TOKEN CREATION COMPLETED!');

    return new Response(
      JSON.stringify({
        success: true,
        token: {
          id: token.id,
          name,
          symbol,
          mint_address: mint.publicKey.toString(),
          bonding_curve_address: bondingCurve.toString(),
          initial_price: initialPrice,
          initial_market_cap: initialMarketCap,
          creator_supply: BONDING_CURVE_CONFIG.CREATOR_SUPPLY,
          bonding_curve_supply: BONDING_CURVE_CONFIG.BONDING_CURVE_SUPPLY,
          program_id: realProgramId,
        },
        transactions: {
          user_payment: userTxId,
          token_creation: createTxId,
        },
        platform_signature: {
          signature: platformSignature,
          expires_at: signatureExpiresAt.toISOString(),
        },
        message: `🚀 ${name} (${symbol}) successfully created with bonding curve!`,
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('=== TOKEN CREATION ERROR ===');
    console.error('Error:', error);
    return new Response(
      JSON.stringify({ 
        error: 'Failed to create token with bonding curve', 
        details: error.message 
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );
  }
});